=head1 I don't understand how you retrieve the data from a SELECT Query with Msql Perl.

=head2 A

    Precanned reply:

    read the README

    read the manpage

    read the FAQ that comes with MsqlPerl

    read the tutorial in t/msql.t

    subscribe to the msqlperl mailing list by sending mail to
    msqlperl-request@franz.ww.tu-berlin.de with "subscribe msqlperl
    your.name@your.domain" in the body of the message. Ask the
    question to the mailing list by writing to
    msqlperl@franz.ww.tu-berlin.de. Wait for the answer. Keep
    subscribed to the mailing list and answer the same question as
    soon as somebody else asks it.

=head1 How do I get the names of the fields after a listfields?

=head2 A

    From the manpage (and there's nothing to be added):

          Statement Handle

          Two constructor methods return a statement handle:

            $sth = $dbh->listfields($table);
            $sth = $dbh->query($sql_statement);

          $sth knows about all metadata that are provided by the API:

            $scalar = $sth->numrows;
            $scalar = $sth->numfields;

            @arr  = $sth->table;       the names of the tables of each column
            @arr  = $sth->name;        the names of the columns
            @arr  = $sth->type;        the type of each column, defined in msql.h
                                       and accessible via &Msql::CHAR_TYPE,
                                       &Msql::INT_TYPE, &Msql::REAL_TYPE,
            @arr  = $sth->isnotnull;   array of boolean
            @arr  = $sth->isprikey;    array of boolean
            @arr  = $sth->length;      array of the length of each field in bytes



          The six last methods return an array in array context and an
          array reference (see the perlref manpage for details) when
          called in a scalar context. The scalar context is useful, if
          you need only the name of one column, e.g.

              $name_of_third_column = $sth->name->[2]

          which is equivalent to

              @all_column_names = $sth->name;
              $name_of_third_column = $all_column_names[2];


=head1 Where can I find more documentation?

     Msql.pm IS the manpage in pod format. If you're on UNIX you should be
     able to read it with 'man Msql'. On other operating systems try
     'perldoc Msql'. Also, the test script, t/msql.t might help you to sort
     things out. The most recent addition is the pmsql program which may
     also help you to learning by example.

=head1 HPUX compilation goes wrong!!!

=head2 A

     From: Yiorgos Adamopoulos <Y.Adamopoulos@noc.ntua.gr>

     I successfully compiled MsqlPerl for a HP817 (HP-UX 9.04/s800) using Perl5.002,
     msql-1.0.14 and gcc-2.7.2.  I added CC_ONLY = -fPIC to site.mm after running
     setup.

=head1 How do I retrieve fields by name?

=head2 A

The internal fetchhash routine is quite good. If you need speed, you
should hardcode your column names into a hash slice. Everything else
is a terrible waste.

		     closure:  8 secs ( 7.47 usr  0.03 sys =  7.50 cpu)
	  hashslice via name: 10 secs ( 9.51 usr  0.04 sys =  9.55 cpu)
	  internal_fetchhash:  7 secs ( 7.05 usr  0.03 sys =  7.08 cpu)
       brute force fetchhash: 15 secs (13.90 usr  0.05 sys = 13.95 cpu)
     hashslice via constants:  6 secs ( 5.57 usr  0.02 sys =  5.59 cpu)

     #!/usr/bin/perl

     use Msql;
     my $db = Msql->Connect("","mod");
     $sth = $db->Query("select * from mods");


     sub Msql::Statement::brute_fetchhash {
	 my $self = shift;
	 my %hash;
	 @hash{ $self->name } = $self->FetchRow and \%hash;
     }

     sub Msql::Statement::gimme_a_fetchhash_routine {
	 my $self = shift;
	 my @z = $sth->name;
	 sub { my %hash; @hash{@z} = $self->FetchRow and \%hash;};
     }

     use Benchmark;

     timethese(20, {
     'hashslice via constants' => q{
	 $sth->DataSeek(0);
	 while (@row{qw/modid userid maillistid chapterid seqdummy statd stats statl stati description changed changedby/} = $sth->FetchRow){
	     $X = $row{modid};
	     print "$X\n" ;
	 }
     },

     '     hashslice via name' => q{
	 $sth->DataSeek(0);
	 while (@row{$sth->name} = $sth->FetchRow){
	     $X = $row{modid};
	     print "$X\n" ;
	 }
     },

     '  brute force fetchhash' => q{
	 $sth->DataSeek(0);
	 while ($hashref = $sth->brute_fetchhash){
	     $X = $hashref->{modid};
	     print "$X\n" ;
	 }
     },
     '                closure' => q{
	 $sth->DataSeek(0);
	 $clos = $sth->gimme_a_fetchhash_routine;
	 while ($hashref = &$clos){
	     $X = $hashref->{modid};
	     print "$X\n" ;
	 }
     },
     '     internal_fetchhash' => q{
	 $sth->DataSeek(0);
	 while (%hash = $sth->fetchhash){
	     $X = $hash{modid};
	     print "$X\n" ;
	 }
     },
     });


=head1 Dynamic Loading

=head2 Q

Hello I am running XXX and would really like to use Msqlperl but I am
getting this error message.

 Can't load module Msql, dynamic loading not available in this perl.
   (You may need to build a new perl executable which either supports
	dynamic loading or has the Msql module statically linked into it.)
  at /usr/lib/perl5/site_perl/Msql.pm line 56
 BEGIN failed--compilation aborted at ./sql.pl line 5.

=head2 A

There is a manpage dedicated to building and installing modules: man
ExtUtils::MakeMaker. The long answer is in there. The short answer is:
run 'make perl' in the MsqlPerl build directory. The third answer is,
get an operating system that supports dynamic loading. With Linux it's
already quite standard to have dynamic loading, and so is with many
other OSs. Check out the newgroups for your OS and consult the FAQs
there.


=head1 How can I construct an insert statement from an array?

The icc routine below should do what you want. It's hardly tested and
I'm reluctant to add it to the distribution. But feel free to convince
me that including it is a good thing.

    #!/usr/bin/perl -w
    use Msql;
    use strict;

    sub Msql::icc {
	my($db,$table,@fields)=@_;
	my($s,@types)=$db->listfields($table) or return;
	if (@fields){
	    # The user wants to input the fields in a different order
	    my(@tfields,@ttypes,%tfields);
	    @tfields = $s->name;
	    @ttypes = $s->type;
	    @tfields{@tfields} = @ttypes;
	    @types = @tfields{@ttypes};
	} else {
	    # They are gonna give the arguments in table's order
	    @fields = $s->name;
	    @types = $s->type;
	}
	# return a subroutine reference.
	sub {
	    my(@arr)=@_;
	    return join " ",
	    "insert into $table values (",
	    join(
		 ",",
		 map {
		     defined $arr[$_] ?
			 $types[$_] == &Msql::REAL_TYPE
			     ||
			 $types[$_] == &Msql::INT_TYPE ?
			     $arr[$_]+0 :
				 Msql->quote($arr[$_]) :
				     "NULL"
				 }
		 0..$#types
		),
		     ")\n";
	}
    }

    # Example for usage:
    {
	my $dbh=Msql->connect("","test");
	my $f=$dbh->icc("pwent");
	my(@info,$query,$sth);
	while (@info = getpwent()) {
	    print $query =&$f(@info);
	    $sth = $dbh->query($query) or die Msql->errmsg;
	}
    }

